<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F24%2FSpring%E4%BA%8B%E5%8A%A1%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[事务(Transaction/tx): 是一系列操作组成的工作单元，该工作单元内的操作是不可分割的，即要么所有操作都做，要么所有 操作都不做，这就是事务。 事务必需满足 ACID（原子性、一致性、隔离性和持久性）特性，缺一不可： 原子性（Atomicity）：事务是不可分割的最小工作单元，事务内的操作要么全做，要么全不做； 一致性（Consistency）：在事务执行前数据库的数据处于正确的状态，而事务执行完成后数据库的数 据依然处于正确的状态，即数据完整性约束没有被破坏，如 A 给 B 转账，不论转账成功与否转账之后的 A 和 B 的账户总额和转账之前是相同的。 隔离性（Isolation）：当多个事务处于并发访问同一个数据库资源时，事务之间相互影响程度，不同 的隔离级别决定了各个事务对数据资源访问的不同行为。 持久性（Durability）：事务一旦执行成功，它对数据库的数据的改变是不可逆的。 用红楼梦里的一句话来描述事务:一损俱损,是非常准确的. 之前,学习过数据库,其中的存在数据库的并发问题,如图: 为了解决这些并发问题，需要通过数据库隔离级别来解决，在标准 SQL 规范中定义了四种隔离级别： READ UNCOMMITED &lt; READ COMMITED&lt;REPEATABLE READ&lt;SERIALIZABLE。 Oracle 支持 READ COMMITED（缺省）和 SERIALIZABLE。 MySQL 支持 四种隔离级别，缺省为 REPEATABLE READ。 其中SERIALIZABLE就表示串行,就没有并发的概念了.(√表示可能出现的情况) 默认情况下MySQL不会出现虚读.除非 select * from 表名 lock in share mode.MySQL中锁基于索引机制,也不会出现第一类丢失更新. 如何选用: 隔离级别越高，数据库事务并发执行性能越差，能处理的操作越少。 因此在实际项目开发中为了考虑并发性能一般使用 READ COMMITED，它能避免丢失更新和脏读，尽管不 可重复读和幻读不能避免， 更多的情况下使用悲观锁或乐观锁来解决。 使用悲观锁或乐观锁来解决。 悲观锁:数据库本身的一种锁,在查询后加上一个FOR UPDATE 乐观锁:在表中定义一个列,来表示每次修改的版本.每次修改的版本号都要加1.更改的时候也要经过版本号来进行更改. 事务类型: 1&gt; 本地事务和分布式事务： 本地事务：就是普通事务，能保证单台数据库上的操作的 ACID，被限定在一台数据库上； 分布式事务：涉及多个数据库源的事务，即跨越多台同类或异类数据库的事务（由每台数据库的本地事务组成的），分布式事务旨在保证这些本地事务的所有操作的 ACID，使事务可以跨越多台数据库； 2&gt; JDBC 事务和 JTA 事务： JDBC 事务：就是数据库事务类型中的本地事务，通过 Connection 对象的控制来管理事务； JTA 事务：JTA 指(Java Transaction API)，是 Java EE 数据库事务规范， JTA 只提供了事务管理接口，由应用程序服务器厂商提供实现，JTA 事务比 JDBC 更强大，支持分布式事务。 3&gt; 编程式事务和声明式事务 编程式事务：通过编写代码来管理事务。 声明式事务： 通过注解或 XML 配置来管理事务； Spring 事务管理 : Spring 的事务管理主要包括 3 个接口： PlatformTransactionManager：根据 TransactionDefinition 提供的事务属性配置信息，创建事务。 平台的事务管理器,是多种事务管理器的基类,涵盖了处理事务的方法 PlatformTransactionManager:提供了事务一些公用的的方法. TransactionDefinition：封装事务的隔离级别和超时时间，是否为只读事务和事务的隔离级别和传播规则等事务属性。 TransactionStatus：封装了事务的具体运行状态。如是否是新开启事务，是否已经提交事务，设置当前事务为 rollback-only 等。 PlatformTransactionManager:接口统一抽象处理事务操作相关的方法，是其他事务管理器的规范； 方法解释： 1):TransactionStatus getTransaction(TransactionDefinition definition)：根据事务定义信息从事务 环境中返回一个已存在的事务，或者创建一个新的事务。 2):void commit(TransactionStatus status)：根据事务的状态提交事务，如果事务状态已经标识为 rollback-only，该方法执行回滚事务的操作。 3):void rollback(TransactionStatus status)：将事务回滚，当 commit 方法抛出异常时，rollback 会 被隐式调用 使用 Spring 管理事务的时候，首先得告诉 Spring 使用哪一个事务管理器 常用的事务管理器： DataSourceTransactionManager：支持 JDBC,MyBatis ； HibernateTransactionManager：支持 Hibernate； TransactionDefinition：封装事务的隔离级别和超时时间，是否为只读事务和事务的隔离级别和传播规则 等事务属性。 事务隔离级别：用来解决并发事务时出现的问题： ISOLATION_DEFAULT：默认隔离级别，即使用底层数据库默认的隔离级别； ISOLATION_READ_UNCOMMITTED：未提交读； ISOLATION_READ_COMMITTED：提交读，一般情况下我们使用这个； ISOLATION_REPEATABLE_READ：可重复读； ISOLATION_SERIALIZABLE：序列化； 事务传播规则（事务传播行为）： 在一个事务方法中调用其他事务方法，此时事务该如何传播，按照什么规则传播，用谁的事务，还是都不用等等？更形象一点的:我是一个抽烟的人,我去你家是抽你的烟还是我的烟?就到底用谁的事务. 事务是如何在这些方法间传播的，Spring 共支持 7 种传播行为：(如上图红色框中) 例子: 情况一：遵从当前事务 REQUIRED：必须存在事务，如果当前存在一个事务，则加入该事务，否则将新建一个事务 （缺省）。使用较多 在aaa方法中调用bbb方法,如果aaa方法中已经有事务了,那么bbb方法中依然用bbb方法中的事务.如果aaa方法中没有事务,则在调用bbb时,bbb中新建一个事务. SUPPORTS：支持当前事务，如果当前存在事务,则使用该事务,否则,以非事务形式运行. 如果当前存在事务就用,不存在就不用.在aaa中调用bbb,如果aaa中有事务,bbb就有,如果aaa中没有,bbb就不用事务. MANDATORY ： 必 须 有 事 务 ， 使 用 当 前 事 务 执 行 ， 如 果 当 前 没 有 事 务 ， 则 抛 出 异 常 IllegalTransactionStateException(非法的事务状态异常)。 情况二：不遵从当前事务 REQUIRES_NEW：不管当前是否存在事务，每次都创建新的事务.使用较多 NOT_SUPPORTRD ：以非事务方式执行，如果当前存在逻辑事务，就把当前事务暂停(挂起)，以非事务方式执行。 在aaa中是有事务的,在调用bbb时,bbb不要事务,就把事务挂在那里不动,在把bbb调用完了又回到aaa的时候就继续拿之前的事务去用. NEVER：不支持事务，如果当前存在是事务，则抛出异常，IllegalTransactionStateException 情况三：寄生事务（外部事务和寄生事务） NESTED ：寄生事务，如果当前存在事务，则在内部事务内执行，如果当前不存在事务，则创建一个新的 事务，寄生事务使用数据库中的savePoint(保存点)来实现，即寄生事务回滚不影响外部事务，但外部事务回滚将导致寄生事务。 DataSourceTransactionManager 默认支持，而 HibernateTransactionManager 默认不支持，需要手动开启。]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈JDK动态代理]]></title>
    <url>%2F2018%2F07%2F22%2F%E6%B5%85%E8%B0%88%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[浅谈JDK动态代理: 首先看看java运行机制:如下图 如源文件为Hello.java,编译之后是Hello.class,程序要运行把该字节码要加载进虚拟机,通过ClassLoader加载(以二进制流的方式),在java虚拟机中通过Java解释器或者即时编译器进行运行,而java虚拟机基于操作系统之上,操作系统基于硬件之上 静态代理：在程序运行前就已经存在代理类的字节码文件，代理对象和真实对象的关系在运行前就确定了。 静态代理:EmployeeServiceProxy.java编译之后产生EmployeeServiceProxy.class文件,把这份字节码加载进虚拟机才能执行,我们绕开这两步,不要写java文件和字节码文件,我们写一个byte数组,写一个二进制流,就按照字节码文件的格式和结构写,通过类加载器加载进虚拟机,这样也能运行程序,省掉了图中左边这部分结构(左边是编译时期,右边是运行时期),这样就没有定义代理类了,这种就称为动态代理(不存在java文件和字节码文件). 动态代理：动态代理类是在程序运行期间由 JVM 通过反射等机制动态的生成的，所以不存在代理类的字节码文件，代理对象和真实对象的关系是在程序运行时期才确定的。 如何动态的加载一份字节码： 由于 JVM 通过字节码的二进制信息加载类的，如果我们在运行期系统中，遵循 Java 编译系统组织.class文件的格式和结构，生成相应的二进制数据，然后再把这个二进制数据加载转换成对应的类。如此，就完成了在代码中动态创建一个类的能力了。 这里就来模拟一下JDK动态代理的原理: 首先先生成代理类的字节码文件.具体代码如下: 123456789101112131415161718192021222324import java.io.FileOutputStream;import cn.wolfcode.service.impl.EmployeeServiceImpl;import sun.misc.ProxyGenerator;public class DynamicProxyClassGenerator &#123; public static void main(String[] args) throws Exception &#123; generateClassFile(EmployeeServiceImpl.class, &quot;EmployeeServiceProxy&quot;); &#125; //生成代理类的字节码文件--&gt;Java反编译工具--&gt;Java文件 public static void generateClassFile(Class targetClass, String proxyName) throws Exception &#123; //根据类信息和提供的代理类名称，生成字节码 byte[] classFile = ProxyGenerator.generateProxyClass(proxyName, targetClass.getInterfaces()); String path = targetClass.getResource(&quot;.&quot;).getPath(); System.out.println(path); FileOutputStream out = null; //保留到硬盘中 out = new FileOutputStream(path + proxyName + &quot;.class&quot;); out.write(classFile); out.close(); &#125;&#125; 第一个参数:真实对象是谁,真实对象的类型,第二个参数:编译之后生成字节码的名字.下面打印了一下待会生成的路径.编译之后生成的字节码的名字是EmployeeServiceProxy, 生成的字节码经过反编译之后再做一些处理的代码,如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import java.util.List;import cn.wolfcode.domain.Employee;import cn.wolfcode.service.IEmployeeService;public final class EmployeeServiceProxy extends Proxy implements IEmployeeService &#123; private static Method method_equals; private static Method method_toString; private static Method method_hashCode; private static Method method_update; private static Method method_save; public EmployeeServiceProxy(InvocationHandler paramInvocationHandler) &#123; super(paramInvocationHandler); &#125; static &#123; try &#123; method_equals = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;,new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;); method_toString = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); method_hashCode = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); method_update = Class.forName(&quot;cn.wolfcode.service.IEmployeeService&quot;).getMethod(&quot;update&quot;,new Class[] &#123; Class.forName(&quot;cn.wolfcode.domain.Employee&quot;) &#125;); method_save = Class.forName(&quot;cn.wolfcode.service.IEmployeeService&quot;).getMethod(&quot;save&quot;,new Class[] &#123; Class.forName(&quot;cn.wolfcode.domain.Employee&quot;) &#125;); &#125; catch (Exception e) &#123; &#125; &#125; public final boolean equals(Object paramObject) &#123; try &#123; return ((Boolean) this.h.invoke(this, method_equals, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error | RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() &#123; try &#123; return (String) this.h.invoke(this, method_toString, null); &#125; catch (Error | RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() &#123; try &#123; return ((Integer) this.h.invoke(this, method_hashCode, null)).intValue(); &#125; catch (Error | RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void save(Employee paramEmployee) &#123; try &#123; this.h.invoke(this, method_save, new Object[] &#123; paramEmployee &#125;); return; &#125; catch (Error | RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void update(Employee paramEmployee) &#123; try &#123; this.h.invoke(this, method_update, new Object[] &#123; paramEmployee &#125;); return; &#125; catch (Error | RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public void delete(Long id) &#123; &#125; public List&lt;Employee&gt; listAll() &#123; return null; &#125;&#125; EmployeeServiceProxy类也实现了IEmploService接口,在静态代理时,真实对象和代理对象都要实现代理接口,只不过现在代理类不是由我们来写,而是动态生成.该类的构造器中传入了InvocationHandler(增强对象)静态代码块是对外面的静态成员做赋值,分别有Object类中的equals,toString,hashCode,以及IEmployeeService类中的update和save,这5个方法就是被增强的方法.最关心的是save和update,下面就是具体怎么去做增强.update中的方法调用this.h.invoke,h是InvocationHandler,也就是说他生成的代理类也就调用invoke方法,这个invoke方法被TransactionManagerAdvice实现了,他传递的第一个参数是代理对象,this就是代理对象,继承了proxy,第二个就是当前被代理的方法save,第三个就是当前save的参数,底层还是调用TransactionManagerAdvice类中的invoke方法.这就是原理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;@SuppressWarnings(&quot;all&quot;)//事务的增强操作public class TransactionManagerAdvice implements java.lang.reflect.InvocationHandler &#123; private Object target;//真实对象(对谁做增强) private TransactionManager txManager;//事务管理器(模拟) public void setTxManager(TransactionManager txManager) &#123; this.txManager = txManager; &#125; public void setTarget(Object target) &#123; this.target = target; &#125; //创建一个代理对象 public &lt;T&gt; T getProxyObject() &#123; return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), //类加载器,一般跟上真实对象的类加载器 target.getClass().getInterfaces(), //真实对象所实现的接口(JDK动态代理必须要求真实对象有接口) this);//如何做事务增强的对象 &#125; //如何为真实对象的方法做增强的具体操作 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (method.getName().startsWith(&quot;get&quot;) || method.getName().startsWith(&quot;list&quot;)) &#123; return method.invoke(target, args);//放行 &#125; Object ret = null; txManager.begin(); try &#123; //--------------------------------------------------------------- ret = method.invoke(target, args);//调用真实对象的方法 //--------------------------------------------------------------- txManager.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); txManager.rollback(); &#125; return ret; &#125;&#125; 此时就和我们静态代理时一样的,只不过此时静态代理类EmployeeServiceProxy不是由我们来创建的,生产字节码对应格式和结构的一个二进制数据加载进虚拟机通过动态的生成这个类. 动态代理原理图: 动态代理原理: 在客户端先得到一个代理对象Proxy对象,通过代理对象调用方法proxy.save(..),其底层生成了一个代理类EmployeeServiceProxy,执行代码1.代理对象底层在执行invoke方法.invoke方法在TransactionManagerAdvice类中代码2.this.h.invoke把三个参数传过来,然后在这里开启事务,再调用真实对象的方法. 其本质就是把save方法代码3做增强,包一层,再包一层. 在这里注意一个小细节:在TransactionManagerAdvice类中的invoke方法中打印proxy,会报栈溢出异常(StackOverflowError), 因为打印的是代理对象,打印对象底层是调用对象的toString方法.(在String类中).而toString方法也是需要被增强的.在这里相当于调用toString,又回来调用invoke方法.需要增强的方法都调用invoke方法.可以调用getClass方法,因为没有对getClass做增强,因为在Object类中,用final修饰,禁止子类覆盖. JDK动态代理总结: 1&gt; JAVA动态代理是使用java.lang.reflect包中的Proxy类与InvocationHandler接口这两个来完成的 2&gt; 要使用JDK动态代理,委托类(真实类)必须要定义接口 3&gt; JDK动态代理将会拦截所有public的方法(因为只能调用接口中定义的方法),这样即使在接口中增加了新的方法,不用修改代码也会被拦截. 4&gt; 动态代理的最小单位是类(所有类中的方法都会被处理),如果只想拦截一部分方法,可以在invoke方法中对要执行的方法名进行判断.]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringIoCMock]]></title>
    <url>%2F2018%2F06%2F24%2FSpringIoCMock%2F</url>
    <content type="text"><![CDATA[SpringIoC管理bean的原理： 1、通过 Resource 对象加载配置文件 2、解析配置文件，得到指定名称的 bean 3、解析 bean 元素，id 作为 bean 的名字，class 用于反射得到 bean 的实例： 注意：此时，bean 类必须存在一个无参数构造器(和访问权限无关)； ​4、调用 getBean 方法的时候，从容器中返回对象实例；结论：就是把代码从JAVA文件中转移到了XML中。 //模拟Spring IoC容器操作 @Test void testIoCMock() throws Exception { String className = &quot;cn.wolfcode.hello.HelloWorld&quot;; HelloWorld world = null; //------------------------------------------------------ //使用反射创建对象 Class clzz = Class.forName(className); Constructor con = clzz.getConstructor(); con.setAccessible(true);//设置构造器的可访问性 Object obj =con.newInstance(); //使用内省机制设置属性值 BeanInfo beanInfo = Introspector.getBeanInfo(clzz,Object.class); PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor pd : pds) { //HelloWorld类中所有的属性名称 String propertyName = pd.getName(); if(&quot;username&quot;.equals(propertyName)) { //调用username的setter方法 pd.getWriteMethod().invoke(obj, &quot;Lucy&quot;); }else if(&quot;age&quot;.equals(propertyName)) { //调用age的setter方法 pd.getWriteMethod().invoke(obj, 18); } } world = (HelloWorld)obj; //------------------------------------------------------ world.sayHello(); }]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
