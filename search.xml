<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈JDK动态代理]]></title>
    <url>%2F2018%2F07%2F22%2F%E6%B5%85%E8%B0%88%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[浅谈JDK动态代理: 首先看看java运行机制:如下图 如源文件为Hello.java,编译之后是Hello.class,程序要运行把该字节码要加载进虚拟机,通过ClassLoader加载(以二进制流的方式),在java虚拟机中通过Java解释器或者即时编译器进行运行,而java虚拟机基于操作系统之上,操作系统基于硬件之上 静态代理：在程序运行前就已经存在代理类的字节码文件，代理对象和真实对象的关系在运行前就确定了。 静态代理:EmployeeServiceProxy.java编译之后产生EmployeeServiceProxy.class文件,把这份字节码加载进虚拟机才能执行,我们绕开这两步,不要写java文件和字节码文件,我们写一个byte数组,写一个二进制流,就按照字节码文件的格式和结构写,通过类加载器加载进虚拟机,这样也能运行程序,省掉了图中左边这部分结构(左边是编译时期,右边是运行时期),这样就没有定义代理类了,这种就称为动态代理(不存在java文件和字节码文件). 动态代理：动态代理类是在程序运行期间由 JVM 通过反射等机制动态的生成的，所以不存在代理类的字节码文件，代理对象和真实对象的关系是在程序运行时期才确定的。 如何动态的加载一份字节码： 由于 JVM 通过字节码的二进制信息加载类的，如果我们在运行期系统中，遵循 Java 编译系统组织.class文件的格式和结构，生成相应的二进制数据，然后再把这个二进制数据加载转换成对应的类。如此，就完成了在代码中动态创建一个类的能力了。 这里就来模拟一下JDK动态代理的原理: 首先先生成代理类的字节码文件.具体代码如下: 123456789101112131415161718192021222324import java.io.FileOutputStream;import cn.wolfcode.service.impl.EmployeeServiceImpl;import sun.misc.ProxyGenerator;public class DynamicProxyClassGenerator &#123; public static void main(String[] args) throws Exception &#123; generateClassFile(EmployeeServiceImpl.class, &quot;EmployeeServiceProxy&quot;); &#125; //生成代理类的字节码文件--&gt;Java反编译工具--&gt;Java文件 public static void generateClassFile(Class targetClass, String proxyName) throws Exception &#123; //根据类信息和提供的代理类名称，生成字节码 byte[] classFile = ProxyGenerator.generateProxyClass(proxyName, targetClass.getInterfaces()); String path = targetClass.getResource(&quot;.&quot;).getPath(); System.out.println(path); FileOutputStream out = null; //保留到硬盘中 out = new FileOutputStream(path + proxyName + &quot;.class&quot;); out.write(classFile); out.close(); &#125;&#125; 第一个参数:真实对象是谁,真实对象的类型,第二个参数:编译之后生成字节码的名字.下面打印了一下待会生成的路径.编译之后生成的字节码的名字是EmployeeServiceProxy, 生成的字节码经过反编译之后再做一些处理的代码,如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import java.util.List;import cn.wolfcode.domain.Employee;import cn.wolfcode.service.IEmployeeService;public final class EmployeeServiceProxy extends Proxy implements IEmployeeService &#123; private static Method method_equals; private static Method method_toString; private static Method method_hashCode; private static Method method_update; private static Method method_save; public EmployeeServiceProxy(InvocationHandler paramInvocationHandler) &#123; super(paramInvocationHandler); &#125; static &#123; try &#123; method_equals = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;,new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;); method_toString = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); method_hashCode = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); method_update = Class.forName(&quot;cn.wolfcode.service.IEmployeeService&quot;).getMethod(&quot;update&quot;,new Class[] &#123; Class.forName(&quot;cn.wolfcode.domain.Employee&quot;) &#125;); method_save = Class.forName(&quot;cn.wolfcode.service.IEmployeeService&quot;).getMethod(&quot;save&quot;,new Class[] &#123; Class.forName(&quot;cn.wolfcode.domain.Employee&quot;) &#125;); &#125; catch (Exception e) &#123; &#125; &#125; public final boolean equals(Object paramObject) &#123; try &#123; return ((Boolean) this.h.invoke(this, method_equals, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error | RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() &#123; try &#123; return (String) this.h.invoke(this, method_toString, null); &#125; catch (Error | RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() &#123; try &#123; return ((Integer) this.h.invoke(this, method_hashCode, null)).intValue(); &#125; catch (Error | RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void save(Employee paramEmployee) &#123; try &#123; this.h.invoke(this, method_save, new Object[] &#123; paramEmployee &#125;); return; &#125; catch (Error | RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void update(Employee paramEmployee) &#123; try &#123; this.h.invoke(this, method_update, new Object[] &#123; paramEmployee &#125;); return; &#125; catch (Error | RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public void delete(Long id) &#123; &#125; public List&lt;Employee&gt; listAll() &#123; return null; &#125;&#125; EmployeeServiceProxy类也实现了IEmploService接口,在静态代理时,真实对象和代理对象都要实现代理接口,只不过现在代理类不是由我们来写,而是动态生成.该类的构造器中传入了InvocationHandler(增强对象)静态代码块是对外面的静态成员做赋值,分别有Object类中的equals,toString,hashCode,以及IEmployeeService类中的update和save,这5个方法就是被增强的方法.最关心的是save和update,下面就是具体怎么去做增强.update中的方法调用this.h.invoke,h是InvocationHandler,也就是说他生成的代理类也就调用invoke方法,这个invoke方法被TransactionManagerAdvice实现了,他传递的第一个参数是代理对象,this就是代理对象,继承了proxy,第二个就是当前被代理的方法save,第三个就是当前save的参数,底层还是调用TransactionManagerAdvice类中的invoke方法.这就是原理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;@SuppressWarnings(&quot;all&quot;)//事务的增强操作public class TransactionManagerAdvice implements java.lang.reflect.InvocationHandler &#123; private Object target;//真实对象(对谁做增强) private TransactionManager txManager;//事务管理器(模拟) public void setTxManager(TransactionManager txManager) &#123; this.txManager = txManager; &#125; public void setTarget(Object target) &#123; this.target = target; &#125; //创建一个代理对象 public &lt;T&gt; T getProxyObject() &#123; return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), //类加载器,一般跟上真实对象的类加载器 target.getClass().getInterfaces(), //真实对象所实现的接口(JDK动态代理必须要求真实对象有接口) this);//如何做事务增强的对象 &#125; //如何为真实对象的方法做增强的具体操作 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (method.getName().startsWith(&quot;get&quot;) || method.getName().startsWith(&quot;list&quot;)) &#123; return method.invoke(target, args);//放行 &#125; Object ret = null; txManager.begin(); try &#123; //--------------------------------------------------------------- ret = method.invoke(target, args);//调用真实对象的方法 //--------------------------------------------------------------- txManager.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); txManager.rollback(); &#125; return ret; &#125;&#125; 此时就和我们静态代理时一样的,只不过此时静态代理类EmployeeServiceProxy不是由我们来创建的,生产字节码对应格式和结构的一个二进制数据加载进虚拟机通过动态的生成这个类. 动态代理原理图: 动态代理原理: 在客户端先得到一个代理对象Proxy对象,通过代理对象调用方法proxy.save(..),其底层生成了一个代理类EmployeeServiceProxy,执行代码1.代理对象底层在执行invoke方法.invoke方法在TransactionManagerAdvice类中代码2.this.h.invoke把三个参数传过来,然后在这里开启事务,再调用真实对象的方法. 其本质就是把save方法代码3做增强,包一层,再包一层. 在这里注意一个小细节:在TransactionManagerAdvice类中的invoke方法中打印proxy,会报栈溢出异常(StackOverflowError), 因为打印的是代理对象,打印对象底层是调用对象的toString方法.(在String类中).而toString方法也是需要被增强的.在这里相当于调用toString,又回来调用invoke方法.需要增强的方法都调用invoke方法.可以调用getClass方法,因为没有对getClass做增强,因为在Object类中,用final修饰,禁止子类覆盖. 总结: JDK动态代理总结: 1&gt; JAVA动态代理是使用java.lang.reflect包中的Proxy类与InvocationHandler接口这两个来完成的 2&gt; 要使用JDK动态代理,委托类(真实类)必须要定义接口 3&gt; JDK动态代理将会拦截所有public的方法(因为只能调用接口中定义的方法),这样即使在接口中增加了新的方法,不用修改代码也会被拦截. 4&gt; 动态代理的最小单位是类(所有类中的方法都会被处理),如果只想拦截一部分方法,可以在invoke方法中对要执行的方法名进行判断.]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringIoCMock]]></title>
    <url>%2F2018%2F06%2F24%2FSpringIoCMock%2F</url>
    <content type="text"><![CDATA[SpringIoC管理bean的原理： 1、通过 Resource 对象加载配置文件 2、解析配置文件，得到指定名称的 bean 3、解析 bean 元素，id 作为 bean 的名字，class 用于反射得到 bean 的实例： 注意：此时，bean 类必须存在一个无参数构造器(和访问权限无关)； ​4、调用 getBean 方法的时候，从容器中返回对象实例；结论：就是把代码从JAVA文件中转移到了XML中。 //模拟Spring IoC容器操作 @Test void testIoCMock() throws Exception { String className = &quot;cn.wolfcode.hello.HelloWorld&quot;; HelloWorld world = null; //------------------------------------------------------ //使用反射创建对象 Class clzz = Class.forName(className); Constructor con = clzz.getConstructor(); con.setAccessible(true);//设置构造器的可访问性 Object obj =con.newInstance(); //使用内省机制设置属性值 BeanInfo beanInfo = Introspector.getBeanInfo(clzz,Object.class); PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor pd : pds) { //HelloWorld类中所有的属性名称 String propertyName = pd.getName(); if(&quot;username&quot;.equals(propertyName)) { //调用username的setter方法 pd.getWriteMethod().invoke(obj, &quot;Lucy&quot;); }else if(&quot;age&quot;.equals(propertyName)) { //调用age的setter方法 pd.getWriteMethod().invoke(obj, 18); } } world = (HelloWorld)obj; //------------------------------------------------------ world.sayHello(); }]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
